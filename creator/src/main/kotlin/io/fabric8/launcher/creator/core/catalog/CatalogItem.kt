package io.fabric8.launcher.creator.core.catalog

import io.fabric8.launcher.creator.core.Properties
import io.fabric8.launcher.creator.core.maven.maven
import io.fabric8.launcher.creator.core.resolveClassPath
import io.fabric8.launcher.creator.core.resource.Resources
import io.fabric8.launcher.creator.core.template.Transformer
import io.fabric8.launcher.creator.core.template.transformFiles
import java.nio.file.*

val PATH_FILES: Path = Paths.get("files")
val PATH_POM: Path = Paths.get("pom.xml")
val PATH_PACKAGE: Path = Paths.get("package.json")
val PATH_MERGE_PACKAGE: Path = Paths.get("merge/package.json")

interface CatalogItem {
    fun apply(resources: Resources, props: Properties, extra: Properties): Resources
}

class CatalogItemContext(public val targetDir: Path) {
}

abstract class BaseCatalogItem(private val ctx: CatalogItemContext) : CatalogItem {
    protected val sourceDir: Path
        get() = Paths.get(this.javaClass.`package`.name.replace('.', '/')
                + "/" + this.javaClass.simpleName.toLowerCase())

    protected val targetDir: Path
        get() = ctx.targetDir

    protected fun <T : Generator> generator(genconst: (CatalogItemContext) -> T): T {
        return genconst(ctx)
    }

    protected fun name(vararg parts: String?): String {
        return parts.filterNotNull().joinToString("-")
    }

    protected fun copy(from: Path = PATH_FILES, to: Path? = null) {
        val from2 = resolveClassPath(sourceDir.resolve(from))
        val to2 = resolveClassPath(if (to != null) targetDir.resolve(to) else targetDir)
        Files.walk(from2).forEach {
            if (!Files.isDirectory(it)) {
                val rel = from2.relativize(it)
                val target = to2.resolve(rel)
                Files.createDirectories(target.parent)
                Files.copy(it, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES)
            }
        }
    }

    protected fun filesCopied(from: Path = PATH_FILES, to: Path? = null): Boolean {
        val from2 = resolveClassPath(sourceDir.resolve(from))
        val to2 = resolveClassPath(if (to != null) targetDir.resolve(to) else targetDir)
        return Files.walk(from2).allMatch {
            val rel = from2.relativize(it)
            val target = to2.resolve(rel)
            Files.exists(target)
        }
    }

    protected fun transform(pattern: String, transformer: Transformer) {
        transformFiles(resolveClassPath(targetDir), pattern, transformer);
    }

    protected fun transform(patterns: List<String>, transformer: Transformer) {
        transformFiles(resolveClassPath(targetDir), patterns, transformer);
    }

    protected fun appendFile(targetFile: String, sourceFile: String? = null) {
        TODO("not implemented")
    }

    protected fun updatePom(appName: String, groupId: String, artifactId: String, version: String, pomFile: Path = PATH_POM) {
        maven.updateMetadata(targetDir.resolve(pomFile), appName, "Generated Application '${appName}'")
        maven.updateGAV(targetDir.resolve(pomFile), groupId, artifactId, version)
    }

    protected fun mergePoms(sourcePom: String = "merge/pom.xml", targetPom: String = "pom.xml") {
        maven.mergePoms(targetDir.resolve(targetPom), resolveClassPath(sourceDir.resolve(sourcePom)))
    }

    protected fun updateMetadata(name: String, description: String = "A new application generated by the Red Hat Application Creator", pomFile: Path = PATH_POM) {
        maven.updateMetadata(targetDir.resolve(pomFile), name, description);
    }

    protected fun mergePackageJson(source: Path = PATH_MERGE_PACKAGE, target: Path = PATH_PACKAGE) {
        TODO("not implemented")
    }
}
